# InEight AI Chatbot - Implementation Plan

## Goal Description

Build an **AI-powered chatbot** that integrates with the existing **InEight Document Management System (DMS)** to answer natural language questions about documents, linked items (RFIs, Transmittals), and document actions. The chatbot will use **RAG (Retrieval-Augmented Generation)** to provide accurate, context-aware responses while respecting user security permissions.

**Key Integration Point**: The DMS is already running on **.NET Framework 4.8.1 + ASP.NET MVC 5 + Entity Framework 6**. The chatbot will be a separate **.NET 8 microservice** that reads metadata from the DMS database and provides an embedded React chat widget.

**MVP Approach**: Start with **free-tier technologies** (PostgreSQL + pgvector, Ollama) with a **provider abstraction layer** that allows seamless upgrade to Azure services (Azure OpenAI, Azure AI Search) via configuration only.

---

## User Review Required

> [!IMPORTANT]
> **Technology Stack Decision**
> 
> This implementation uses a **hybrid approach** with provider abstraction:
> - **MVP (Phase 1)**: Free-tier technologies
>   - AI: Ollama (Llama 3) - Self-hosted, $0/month
>   - Vector DB: PostgreSQL + pgvector - Self-hosted, $0/month
>   - Performance: 2-5 second response time
>   - Scalability: Single server
> 
> - **Production (Phase 2)**: Azure services (config-only switch)
>   - AI: Azure OpenAI (GPT-4o)
>   - Vector DB: Azure AI Search
>   - Performance: 1-2 second response time
>   - Scalability: Auto-scale
> 
> **Benefit**: Build and test with $0 cost, upgrade to Azure when ready without code changes.

> [!WARNING]
> **DMS Integration Considerations**
> 
> The chatbot connects to the existing DMS database:
> - **User Authentication**: ASP.NET Identity 2.0 (`AspNetUsers` table with integer IDs)
> - **Database**: SQL Server (LocalDB for dev, can be Azure SQL for prod)
> - **Security**: JWT tokens generated by DMS, validated by chatbot
> - **Access Control**: Respects project assignments (`ProjectUsers` table) and manager roles
> - **No File Access**: Only metadata is indexed, files remain in DMS blob storage

> [!NOTE]
> **Chat Features**
> 
> - Natural language search across 26+ document metadata fields
> - Query linked items (RFIs, Transmittals, Forms, Tasks, Mail)
> - Query document actions (updates, reviews, Bluebeam edits)
> - User-specific results (security-filtered)
> - Chat history with session management
> - Failed query handling with Knowledge Base links
> - Admin analytics dashboard

---

## Proposed Changes

Project location: `d:\Code\ineight\projects\InEightDocumentAISuite\InEightAIChatbot`

---

### Component 1: Solution Structure

#### [NEW] [InEightAIChatbot.sln](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.sln)

```
InEightAIChatbot.sln
â”œâ”€â”€ InEightAIChatbot.Service (ASP.NET Core 8 Web API)
â”œâ”€â”€ InEightAIChatbot.Core (Class Library - Domain Models, Interfaces)
â”œâ”€â”€ InEightAIChatbot.Infrastructure (Class Library - Provider Implementations)
â””â”€â”€ InEightAIChatbot.Widget (React + Vite - Chat UI)
```

**Create via CLI**:
```powershell
# Navigate to project root
cd d:\Code\ineight\projects\InEightDocumentAISuite\InEightAIChatbot

# Create solution
dotnet new sln -n InEightAIChatbot

# Create projects
dotnet new webapi -n InEightAIChatbot.Service -f net8.0
dotnet new classlib -n InEightAIChatbot.Core -f net8.0
dotnet new classlib -n InEightAIChatbot.Infrastructure -f net8.0

# Add to solution
dotnet sln InEightAIChatbot.sln add InEightAIChatbot.Service
dotnet sln InEightAIChatbot.sln add InEightAIChatbot.Core
dotnet sln InEightAIChatbot.sln add InEightAIChatbot.Infrastructure

# Add project references
dotnet add InEightAIChatbot.Service reference InEightAIChatbot.Core
dotnet add InEightAIChatbot.Service reference InEightAIChatbot.Infrastructure
dotnet add InEightAIChatbot.Infrastructure reference InEightAIChatbot.Core

# Create React widget
npm create vite@latest InEightAIChatbot.Widget -- --template react-ts
```

---

### Component 2: Core Abstractions (InEightAIChatbot.Core)

#### [NEW] [Interfaces/IAIProvider.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Core/Interfaces/IAIProvider.cs)

Provider abstraction for AI operations:

```csharp
namespace InEightAIChatbot.Core.Interfaces;

public interface IAIProvider
{
    /// <summary>
    /// Generate text completion from prompts
    /// </summary>
    Task<string> GenerateCompletionAsync(
        string systemPrompt, 
        string userPrompt, 
        CancellationToken ct = default);
    
    /// <summary>
    /// Generate embedding vector for text
    /// </summary>
    Task<float[]> GenerateEmbeddingAsync(
        string text, 
        CancellationToken ct = default);
    
    /// <summary>
    /// Provider name for logging
    /// </summary>
    string ProviderName { get; }
    
    /// <summary>
    /// Embedding vector dimensions
    /// </summary>
    int EmbeddingDimensions { get; }
}
```

#### [NEW] [Interfaces/IVectorSearchProvider.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Core/Interfaces/IVectorSearchProvider.cs)

Provider abstraction for vector search:

```csharp
namespace InEightAIChatbot.Core.Interfaces;

public interface IVectorSearchProvider
{
    /// <summary>
    /// Index document metadata with embedding
    /// </summary>
    Task IndexDocumentAsync(
        int documentId, 
        string text, 
        float[] embedding, 
        Dictionary<string, object> metadata,
        int[] accessibleUserIds,
        CancellationToken ct = default);
    
    /// <summary>
    /// Search documents by embedding similarity (user-filtered)
    /// </summary>
    Task<SearchResult[]> SearchAsync(
        float[] queryEmbedding, 
        int userId, 
        int topK = 10,
        CancellationToken ct = default);
    
    /// <summary>
    /// Delete document from index
    /// </summary>
    Task DeleteDocumentAsync(int documentId, CancellationToken ct = default);
    
    string ProviderName { get; }
}

public record SearchResult(
    int DocumentId,
    string Text,
    Dictionary<string, object> Metadata,
    float Distance
);
```

#### [NEW] [Models/ChatModels.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Core/Models/ChatModels.cs)

```csharp
namespace InEightAIChatbot.Core.Models;

public record ChatRequest(
    string Query,
    int? ProjectId,
    string? SessionId
);

public record ChatResponse(
    string Answer,
    ChatLink[] Links,
    float Confidence,
    string? FallbackKBLink
);

public record ChatLink(
    string Type, // "document" | "filtered_view"
    int? Id,
    string Title,
    string Url
);

public record ChatSession(
    string Id,
    int UserId,
    string Title,
    DateTime CreatedAt
);

public record ChatMessage(
    string Id,
    string SessionId,
    string Role, // "user" | "assistant"
    string Content,
    DateTime Timestamp,
    Dictionary<string, object>? Metadata
);
```

---

### Component 3: Infrastructure Providers (InEightAIChatbot.Infrastructure)

#### [NEW] [Providers/OllamaProvider.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Infrastructure/Providers/OllamaProvider.cs)

**[MVP IMPLEMENTATION]** - Ollama integration for free-tier AI:

```csharp
using InEightAIChatbot.Core.Interfaces;
using Microsoft.Extensions.Options;
using System.Text.Json;

namespace InEightAIChatbot.Infrastructure.Providers;

public class OllamaProvider : IAIProvider
{
    private readonly HttpClient _httpClient;
    private readonly OllamaSettings _settings;
    
    public string ProviderName => "Ollama";
    public int EmbeddingDimensions => 384; // nomic-embed-text
    
    public OllamaProvider(HttpClient httpClient, IOptions<OllamaSettings> settings)
    {
        _httpClient = httpClient;
        _settings = settings.Value;
    }
    
    public async Task<string> GenerateCompletionAsync(
        string systemPrompt, 
        string userPrompt, 
        CancellationToken ct = default)
    {
        var request = new
        {
            model = _settings.Model,
            prompt = $"{systemPrompt}\n\n{userPrompt}",
            stream = false,
            options = new
            {
                temperature = 0.7,
                top_p = 0.9
            }
        };
        
        var response = await _httpClient.PostAsJsonAsync(
            $"{_settings.Endpoint}/api/generate", 
            request, ct);
        
        response.EnsureSuccessStatusCode();
        
        var result = await response.Content.ReadFromJsonAsync<OllamaResponse>(ct);
        return result!.Response;
    }
    
    public async Task<float[]> GenerateEmbeddingAsync(
        string text, 
        CancellationToken ct = default)
    {
        var request = new
        {
            model = _settings.EmbeddingModel,
            prompt = text
        };
        
        var response = await _httpClient.PostAsJsonAsync(
            $"{_settings.Endpoint}/api/embeddings", 
            request, ct);
        
        response.EnsureSuccessStatusCode();
        
        var result = await response.Content.ReadFromJsonAsync<OllamaEmbeddingResponse>(ct);
        return result!.Embedding;
    }
}

public class OllamaSettings
{
    public string Endpoint { get; set; } = "http://localhost:11434";
    public string Model { get; set; } = "llama3";
    public string EmbeddingModel { get; set; } = "nomic-embed-text";
}

internal record OllamaResponse(string Response);
internal record OllamaEmbeddingResponse(float[] Embedding);
```

#### [NEW] [Providers/PgVectorProvider.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Infrastructure/Providers/PgVectorProvider.cs)

**[MVP IMPLEMENTATION]** - PostgreSQL + pgvector for free-tier vector search:

```csharp
using InEightAIChatbot.Core.Interfaces;
using Npgsql;
using Pgvector;
using System.Text.Json;

namespace InEightAIChatbot.Infrastructure.Providers;

public class PgVectorProvider : IVectorSearchProvider
{
    private readonly NpgsqlDataSource _dataSource;
    
    public string ProviderName => "PostgreSQL + pgvector";
    
    public PgVectorProvider(NpgsqlDataSource dataSource)
    {
        _dataSource = dataSource;
    }
    
    public async Task IndexDocumentAsync(
        int documentId, 
        string text, 
        float[] embedding, 
        Dictionary<string, object> metadata,
        int[] accessibleUserIds,
        CancellationToken ct = default)
    {
        await using var cmd = _dataSource.CreateCommand(@"
            INSERT INTO document_embeddings 
            (document_id, chunk_text, embedding, metadata, user_access_list, updated_at)
            VALUES ($1, $2, $3, $4, $5, NOW())
            ON CONFLICT (document_id) 
            DO UPDATE SET 
                chunk_text = EXCLUDED.chunk_text,
                embedding = EXCLUDED.embedding,
                metadata = EXCLUDED.metadata,
                user_access_list = EXCLUDED.user_access_list,
                updated_at = NOW()");
        
        cmd.Parameters.AddWithValue(documentId);
        cmd.Parameters.AddWithValue(text);
        cmd.Parameters.AddWithValue(new Vector(embedding));
        cmd.Parameters.AddWithValue(JsonSerializer.Serialize(metadata));
        cmd.Parameters.AddWithValue(accessibleUserIds);
        
        await cmd.ExecuteNonQueryAsync(ct);
    }
    
    public async Task<SearchResult[]> SearchAsync(
        float[] queryEmbedding, 
        int userId, 
        int topK = 10,
        CancellationToken ct = default)
    {
        await using var cmd = _dataSource.CreateCommand(@"
            SELECT document_id, chunk_text, metadata,
                   embedding <=> $1 AS distance
            FROM document_embeddings
            WHERE $2 = ANY(user_access_list)
            ORDER BY distance
            LIMIT $3");
        
        cmd.Parameters.AddWithValue(new Vector(queryEmbedding));
        cmd.Parameters.AddWithValue(userId);
        cmd.Parameters.AddWithValue(topK);
        
        var results = new List<SearchResult>();
        await using var reader = await cmd.ExecuteReaderAsync(ct);
        
        while (await reader.ReadAsync(ct))
        {
            results.Add(new SearchResult(
                DocumentId: reader.GetInt32(0),
                Text: reader.GetString(1),
                Metadata: JsonSerializer.Deserialize<Dictionary<string, object>>(
                    reader.GetString(2))!,
                Distance: reader.GetFloat(3)
            ));
        }
        
        return results.ToArray();
    }
    
    public async Task DeleteDocumentAsync(int documentId, CancellationToken ct = default)
    {
        await using var cmd = _dataSource.CreateCommand(
            "DELETE FROM document_embeddings WHERE document_id = $1");
        cmd.Parameters.AddWithValue(documentId);
        await cmd.ExecuteNonQueryAsync(ct);
    }
}
```

#### [NEW] [Providers/AzureOpenAIProvider.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Infrastructure/Providers/AzureOpenAIProvider.cs)

**[STUB FOR PHASE 2]** - Template for Azure upgrade:

```csharp
using InEightAIChatbot.Core.Interfaces;

namespace InEightAIChatbot.Infrastructure.Providers;

public class AzureOpenAIProvider : IAIProvider
{
    public string ProviderName => "Azure OpenAI";
    public int EmbeddingDimensions => 1536; // text-embedding-ada-002
    
    public Task<string> GenerateCompletionAsync(
        string systemPrompt, 
        string userPrompt, 
        CancellationToken ct = default)
    {
        throw new NotImplementedException(
            "Phase 2: Install Azure.AI.OpenAI NuGet package and implement using OpenAIClient");
    }
    
    public Task<float[]> GenerateEmbeddingAsync(string text, CancellationToken ct = default)
    {
        throw new NotImplementedException(
            "Phase 2: Use Azure OpenAI embeddings API");
    }
}
```

#### [NEW] [Providers/AzureAISearchProvider.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Infrastructure/Providers/AzureAISearchProvider.cs)

**[STUB FOR PHASE 2]**:

```csharp
using InEightAIChatbot.Core.Interfaces;

namespace InEightAIChatbot.Infrastructure.Providers;

public class AzureAISearchProvider : IVectorSearchProvider
{
    public string ProviderName => "Azure AI Search";
    
    public Task IndexDocumentAsync(
        int documentId, 
        string text, 
        float[] embedding, 
        Dictionary<string, object> metadata,
        int[] accessibleUserIds,
        CancellationToken ct = default)
    {
        throw new NotImplementedException(
            "Phase 2: Install Azure.Search.Documents and use SearchClient.UploadDocumentsAsync");
    }
    
    public Task<SearchResult[]> SearchAsync(
        float[] queryEmbedding, 
        int userId, 
        int topK = 10,
        CancellationToken ct = default)
    {
        throw new NotImplementedException(
            "Phase 2: Use SearchClient.SearchAsync with vector search");
    }
    
    public Task DeleteDocumentAsync(int documentId, CancellationToken ct = default)
    {
        throw new NotImplementedException("Phase 2");
    }
}
```

---

### Component 4: Core Services (InEightAIChatbot.Service)

#### [NEW] [Services/MetadataSyncService.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Service/Services/MetadataSyncService.cs)

Background service to sync DMS metadata to vector database:

```csharp
using InEightAIChatbot.Core.Interfaces;
using Microsoft.Data.SqlClient;
using Microsoft.Extensions.Options;

namespace InEightAIChatbot.Service.Services;

public class MetadataSyncService : BackgroundService
{
    private readonly IAIProvider _aiProvider;
    private readonly IVectorSearchProvider _vectorSearch;
    private readonly ILogger<MetadataSyncService> _logger;
    private readonly string _dmsConnectionString;
    
    public MetadataSyncService(
        IAIProvider aiProvider,
        IVectorSearchProvider vectorSearch,
        ILogger<MetadataSyncService> logger,
        IConfiguration configuration)
    {
        _aiProvider = aiProvider;
        _vectorSearch = vectorSearch;
        _logger = logger;
        _dmsConnectionString = configuration.GetConnectionString("DMSDatabase")!;
    }
    
    protected override async Task ExecuteAsync(CancellationToken ct)
    {
        _logger.LogInformation("MetadataSyncService started using {Provider} and {VectorStore}", 
            _aiProvider.ProviderName, _vectorSearch.ProviderName);
        
        // Initial sync
        await SyncAllDocumentsAsync(ct);
        
        // Periodic sync every 4 hours
        while (!ct.IsCancellationRequested)
        {
            await Task.Delay(TimeSpan.FromHours(4), ct);
            await SyncAllDocumentsAsync(ct);
        }
    }
    
    private async Task SyncAllDocumentsAsync(CancellationToken ct)
    {
        _logger.LogInformation("Starting document metadata sync...");
        
        await using var connection = new SqlConnection(_dmsConnectionString);
        await connection.OpenAsync(ct);
        
        // Query documents with all metadata from DMS database
        var query = @"
            SELECT 
                d.Id, d.Name, d.Description, d.Type, d.Category, d.Tags,
                d.Status, d.TransmittalNumber, d.Version, d.RevisionNumber,
                d.UploadedAt, d.ProjectId,
                u.Name AS UploadedByName,
                p.Name AS ProjectName,
                d.ApprovalStatus
            FROM Documents d
            INNER JOIN AspNetUsers u ON d.UploadedById = u.Id
            INNER JOIN Projects p ON d.ProjectId = p.Id
            WHERE d.Status != 6"; // Exclude archived
        
        await using var cmd = new SqlCommand(query, connection);
        await using var reader = await cmd.ExecuteReaderAsync(ct);
        
        int synced = 0;
        while (await reader.ReadAsync(ct))
        {
            var documentId = reader.GetInt32(0);
            var text = FormatDocumentMetadata(reader);
            var metadata = ExtractMetadata(reader);
            var accessibleUserIds = await GetAccessibleUserIdsAsync(
                reader.GetInt32(11), ct); // ProjectId
            
            // Generate embedding
            var embedding = await _aiProvider.GenerateEmbeddingAsync(text, ct);
            
            // Index
            await _vectorSearch.IndexDocumentAsync(
                documentId, text, embedding, metadata, accessibleUserIds, ct);
            
            synced++;
        }
        
        _logger.LogInformation("Synced {Count} documents", synced);
    }
    
    private string FormatDocumentMetadata(SqlDataReader reader)
    {
        return $"Document: {reader.GetString(1)}\n" +
               $"Description: {reader.GetString(2)}\n" +
               $"Type: {reader.GetString(3)}\n" +
               $"Category: {reader.GetString(4)}\n" +
               $"Status: {reader.GetInt32(6)}\n" +
               $"Project: {reader.GetString(13)}\n" +
               $"Uploaded By: {reader.GetString(12)} on {reader.GetDateTime(10):yyyy-MM-dd}\n" +
               $"Transmittal: {(reader.IsDBNull(7) ? "None" : reader.GetString(7))}\n" +
               $"Version: {reader.GetInt32(8)}, Revision: {reader.GetInt32(9)}";
    }
    
    private Dictionary<string, object> ExtractMetadata(SqlDataReader reader)
    {
        return new Dictionary<string, object>
        {
            ["documentId"] = reader.GetInt32(0),
            ["name"] = reader.GetString(1),
            ["type"] = reader.GetString(3),
            ["projectId"] = reader.GetInt32(11),
            ["projectName"] = reader.GetString(13),
            ["status"] = reader.GetInt32(6)
        };
    }
    
    private async Task<int[]> GetAccessibleUserIdsAsync(int projectId, CancellationToken ct)
    {
        await using var connection = new SqlConnection(_dmsConnectionString);
        await connection.OpenAsync(ct);
        
        // Get project manager + all project users
        var query = @"
            SELECT DISTINCT u.Id
            FROM AspNetUsers u
            LEFT JOIN Projects p ON p.ManagerId = u.Id
            LEFT JOIN ProjectUsers pu ON pu.UserId = u.Id
            WHERE p.Id = @ProjectId OR pu.ProjectId = @ProjectId OR u.Role = 1"; // Include admins
        
        await using var cmd = new SqlCommand(query, connection);
        cmd.Parameters.AddWithValue("@ProjectId", projectId);
        
        var userIds = new List<int>();
        await using var reader = await cmd.ExecuteReaderAsync(ct);
        while (await reader.ReadAsync(ct))
        {
            userIds.Add(reader.GetInt32(0));
        }
        
        return userIds.ToArray();
    }
}
```

#### [NEW] [Services/RAGOrchestrator.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Service/Services/RAGOrchestrator.cs)

Core RAG pipeline (provider-agnostic):

```csharp
using InEightAIChatbot.Core.Interfaces;
using InEightAIChatbot.Core.Models;

namespace InEightAIChatbot.Service.Services;

public class RAGOrchestrator
{
    private readonly IAIProvider _aiProvider;
    private readonly IVectorSearchProvider _vectorSearch;
    private readonly ILogger<RAGOrchestrator> _logger;
    
    public RAGOrchestrator(
        IAIProvider aiProvider,
        IVectorSearchProvider vectorSearch,
        ILogger<RAGOrchestrator> logger)
    {
        _aiProvider = aiProvider;
        _vectorSearch = vectorSearch;
        _logger = logger;
    }
    
    public async Task<ChatResponse> ProcessQueryAsync(
        string userQuery, 
        int userId, 
        CancellationToken ct = default)
    {
        _logger.LogInformation("Processing query for user {UserId}: {Query}", userId, userQuery);
        
        // 1. Generate query embedding
        var queryEmbedding = await _aiProvider.GenerateEmbeddingAsync(userQuery, ct);
        
        // 2. Semantic search (user-filtered)
        var results = await _vectorSearch.SearchAsync(queryEmbedding, userId, topK: 10, ct);
        
        if (results.Length == 0)
        {
            return new ChatResponse(
                Answer: "I couldn't find any documents matching your query. You may not have access to relevant documents, or they may not exist.",
                Links: Array.Empty<ChatLink>(),
                Confidence: 0,
                FallbackKBLink: "https://learn.ineight.com/Document_Enhanced/Content/Categories/Home-Page.htm"
            );
        }
        
        // 3. Build context from top results
        var context = string.Join("\n\n", results.Select(r => r.Text));
        
        // 4. Generate answer using LLM
        var systemPrompt = @"You are a helpful document management assistant for InEight Document system.
Answer questions based ONLY on the provided context. 
Be concise and specific. 
If you reference a document, mention its name.
If the context doesn't contain enough information, say so.";
        
        var userPrompt = $"Context:\n{context}\n\nQuestion: {userQuery}";
        
        var answer = await _aiProvider.GenerateCompletionAsync(systemPrompt, userPrompt, ct);
        
        // 5. Calculate confidence based on semantic distance
        var avgDistance = results.Average(r => r.Distance);
        var confidence = 1.0f - Math.Min(avgDistance, 1.0f);
        
        // 6. Build response links
        var links = results
            .Take(5)
            .Select(r => new ChatLink(
                Type: "document",
                Id: r.DocumentId,
                Title: r.Metadata["name"].ToString()!,
                Url: $"/Documents/Details/{r.DocumentId}?projectId={r.Metadata["projectId"]}"
            ))
            .ToArray();
        
        return new ChatResponse(
            Answer: answer,
            Links: links,
            Confidence: confidence,
            FallbackKBLink: confidence < 0.7f 
                ? "https://learn.ineight.com/Document_Enhanced/Content/Categories/Home-Page.htm" 
                : null
        );
    }
}
```

---

### Component 5: API Configuration & Endpoints

#### [NEW] [appsettings.json](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Service/appsettings.json)

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  
  "AI": {
    "Provider": "Ollama",
    "VectorStore": "PgVector",
    
    "Ollama": {
      "Endpoint": "http://localhost:11434",
      "Model": "llama3",
      "EmbeddingModel": "nomic-embed-text"
    },
    
    "AzureOpenAI": {
      "Endpoint": "https://[PHASE-2].openai.azure.com/",
      "ApiKey": "[PHASE-2-KEY]",
      "DeploymentName": "gpt-4o",
      "EmbeddingDeployment": "text-embedding-ada-002"
    },
    
    "AzureAISearch": {
      "Endpoint": "https://[PHASE-2].search.windows.net",
      "ApiKey": "[PHASE-2-KEY]",
      "IndexName": "documents"
    }
  },
  
  "ConnectionStrings": {
    "DMSDatabase": "Data Source=(LocalDb)\\MSSQLLocalDB;Initial Catalog=InEightDMS;Integrated Security=True",
    "PostgreSQL": "Host=localhost;Database=ineightchatbot;Username=postgres;Password=dev123"
  },
  
  "Jwt": {
    "SecretKey": "your-secret-key-min-32-chars-shared-with-dms",
    "Issuer": "InEightDMS",
    "Audience": "InEightChatbot"
  }
}
```

#### [NEW] [Program.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Service/Program.cs)

```csharp
using InEightAIChatbot.Core.Interfaces;
using InEightAIChatbot.Infrastructure.Providers;
using InEightAIChatbot.Service.Services;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using Npgsql;
using Pgvector.Npgsql;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Configure CORS for DMS integration
builder.Services.AddCors(options =>
{
    options.AddPolicy("DMS", policy =>
    {
        policy.WithOrigins("http://localhost:*", "https://localhost:*")
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});

// JWT Authentication
var jwtSettings = builder.Configuration.GetSection("Jwt");
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = jwtSettings["Issuer"],
            ValidAudience = jwtSettings["Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(jwtSettings["SecretKey"]!))
        };
    });

// PostgreSQL with pgvector
var pgConnectionString = builder.Configuration.GetConnectionString("PostgreSQL")!;
var dataSourceBuilder = new NpgsqlDataSourceBuilder(pgConnectionString);
dataSourceBuilder.UseVector();
builder.Services.AddSingleton(dataSourceBuilder.Build());

// Configure AI Providers based on settings
var aiProvider = builder.Configuration["AI:Provider"];
var vectorProvider = builder.Configuration["AI:VectorStore"];

builder.Services.Configure<OllamaSettings>(
    builder.Configuration.GetSection("AI:Ollama"));

builder.Services.AddHttpClient<IAIProvider, OllamaProvider>();

builder.Services.AddSingleton<IAIProvider>(sp =>
{
    return aiProvider switch
    {
        "Ollama" => sp.GetRequiredService<OllamaProvider>(),
        "AzureOpenAI" => new AzureOpenAIProvider(),
        _ => throw new InvalidOperationException($"Unknown AI provider: {aiProvider}")
    };
});

builder.Services.AddSingleton<IVectorSearchProvider>(sp =>
{
    return vectorProvider switch
    {
        "PgVector" => new PgVectorProvider(sp.GetRequiredService<NpgsqlDataSource>()),
        "AzureAISearch" => new AzureAISearchProvider(),
        _ => throw new InvalidOperationException($"Unknown vector provider: {vectorProvider}")
    };
});

// Core services
builder.Services.AddSingleton<RAGOrchestrator>();
builder.Services.AddHostedService<MetadataSyncService>();

var app = builder.Build();

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseCors("DMS");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

#### [NEW] [Controllers/ChatController.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Service/Controllers/ChatController.cs)

```csharp
using InEightAIChatbot.Core.Models;
using InEightAIChatbot.Service.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

namespace InEightAIChatbot.Service.Controllers;

[ApiController]
[Route("api/chat")]
[Authorize]
public class ChatController : ControllerBase
{
    private readonly RAGOrchestrator _ragOrchestrator;
    private readonly ILogger<ChatController> _logger;
    
    public ChatController(RAGOrchestrator ragOrchestrator, ILogger<ChatController> logger)
    {
        _ragOrchestrator = ragOrchestrator;
        _logger = logger;
    }
    
    [HttpPost("message")]
    public async Task<IActionResult> SendMessage(
        [FromBody] ChatRequest request,
        CancellationToken ct)
    {
        var userId = GetUserId();
        
        _logger.LogInformation("Chat request from user {UserId}: {Query}", userId, request.Query);
        
        var response = await _ragOrchestrator.ProcessQueryAsync(
            request.Query, 
            userId, 
            ct);
        
        return Ok(response);
    }
    
    private int GetUserId()
    {
        var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        return int.Parse(userIdClaim!);
    }
}
```

---

### Component 6: Database Setup

#### [NEW] [Database/PostgreSQL/setup.sql](file:///d:/Code/ineight/projects/InEightDocumentAISuite/Database/PostgreSQL/setup.sql)

```sql
-- Enable pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;

-- Document embeddings table
CREATE TABLE document_embeddings (
    id SERIAL PRIMARY KEY,
    document_id INT NOT NULL UNIQUE,
    chunk_text TEXT NOT NULL,
    embedding vector(384), -- nomic-embed-text dimensions
    metadata JSONB,
    user_access_list INT[],
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Create index for fast similarity search
CREATE INDEX document_embeddings_embedding_idx 
ON document_embeddings 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- Index for user access filtering
CREATE INDEX document_embeddings_access_idx 
ON document_embeddings 
USING GIN (user_access_list);

-- Linked items embeddings (RFI, Transmittals, etc.)
CREATE TABLE linked_item_embeddings (
    id SERIAL PRIMARY KEY,
    item_id INT NOT NULL,
    item_type VARCHAR(50) NOT NULL,
    document_id INT NOT NULL,
    chunk_text TEXT NOT NULL,
    embedding vector(384),
    metadata JSONB,
    user_access_list INT[],
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX linked_item_embeddings_embedding_idx 
ON linked_item_embeddings 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 50);

-- Chat sessions
CREATE TABLE chat_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id INT NOT NULL,
    title VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Chat messages
CREATE TABLE chat_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL, -- 'user' or 'assistant'
    content TEXT NOT NULL,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX chat_messages_session_idx ON chat_messages(session_id);

-- Failed queries log
CREATE TABLE failed_queries (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL,
    query TEXT NOT NULL,
    reason VARCHAR(255),
    suggested_kb_link TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);
```

**Setup Instructions**:

```powershell
# Option 1: Docker (Recommended)
docker run --name postgres-ineight `
  -e POSTGRES_PASSWORD=dev123 `
  -e POSTGRES_DB=ineightchatbot `
  -p 5432:5432 `
  -d ankane/pgvector:latest

# Run setup script
Get-Content Database\PostgreSQL\setup.sql | docker exec -i postgres-ineight psql -U postgres -d ineightchatbot

# Option 2: Local PostgreSQL
# Install PostgreSQL 16 with pgvector extension
# Then run: psql -U postgres -d ineightchatbot -f Database\PostgreSQL\setup.sql
```

---

### Component 7: React Chat Widget

#### [NEW] [InEightAIChatbot.Widget/package.json](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Widget/package.json)

```json
{
  "name": "ineight-ai-chatbot-widget",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "lucide-react": "^0.294.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@vitejs/plugin-react": "^4.2.1",
    "typescript": "^5.2.2",
    "vite": "^5.0.8"
  }
}
```

#### [NEW] [InEightAIChatbot.Widget/src/ChatWidget.tsx](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightAIChatbot/InEightAIChatbot.Widget/src/ChatWidget.tsx)

```tsx
import React, { useState } from 'react';
import { MessageCircle, X, Send } from 'lucide-react';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  links?: Array<{
    type: string;
    id?: number;
    title: string;
    url: string;
  }>;
}

interface ChatWidgetProps {
  apiBaseUrl: string;
  jwtToken: string;
}

export function ChatWidget({ apiBaseUrl, jwtToken }: ChatWidgetProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);

  const sendMessage = async () => {
    if (!input.trim()) return;

    const userMessage: Message = { role: 'user', content: input };
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setLoading(true);

    try {
      const response = await fetch(`${apiBaseUrl}/api/chat/message`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${jwtToken}`
        },
        body: JSON.stringify({ query: input })
      });

      const data = await response.json();
      
      const assistantMessage: Message = {
        role: 'assistant',
        content: data.answer,
        links: data.links
      };
      
      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Chat error:', error);
      setMessages(prev => [...prev, {
        role: 'assistant',
        content: 'Sorry, I encountered an error. Please try again.'
      }]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      {/* Floating Button */}
      {!isOpen && (
        <button
          onClick={() => setIsOpen(true)}
          className="fixed bottom-6 right-6 bg-blue-600 text-white p-4 rounded-full shadow-lg hover:bg-blue-700 transition-all"
        >
          <MessageCircle size={24} />
        </button>
      )}

      {/* Chat Window */}
      {isOpen && (
        <div className="fixed bottom-6 right-6 w-96 h-[600px] bg-white rounded-lg shadow-2xl flex flex-col">
          {/* Header */}
          <div className="bg-blue-600 text-white p-4 rounded-t-lg flex justify-between items-center">
            <h3 className="font-semibold">InEight AI Assistant</h3>
            <button onClick={() => setIsOpen(false)}>
              <X size={20} />
            </button>
          </div>

          {/* Messages */}
          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            {messages.map((msg, idx) => (
              <div key={idx} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                <div className={`max-w-[80%] p-3 rounded-lg ${
                  msg.role === 'user' 
                    ? 'bg-blue-600 text-white' 
                    : 'bg-gray-100 text-gray-800'
                }`}>
                  <p className="text-sm">{msg.content}</p>
                  {msg.links && msg.links.length > 0 && (
                    <div className="mt-2 space-y-1">
                      {msg.links.map((link, i) => (
                        <a
                          key={i}
                          href={link.url}
                          className="block text-xs underline hover:no-underline"
                        >
                          ðŸ“„ {link.title}
                        </a>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            ))}
            {loading && (
              <div className="flex justify-start">
                <div className="bg-gray-100 p-3 rounded-lg">
                  <p className="text-sm text-gray-600">Thinking...</p>
                </div>
              </div>
            )}
          </div>

          {/* Input */}
          <div className="p-4 border-t">
            <div className="flex gap-2">
              <input
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
                placeholder="Ask about documents..."
                className="flex-1 px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-600"
              />
              <button
                onClick={sendMessage}
                disabled={loading}
                className="bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 disabled:opacity-50"
              >
                <Send size={20} />
              </button>
            </div>
          </div>
        </div>
      )}
    </>
  );
}
```

---

### Component 8: DMS Integration

#### [MODIFY] [InEightDMS.Web/Views/Shared/_Layout.cshtml](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightDMS/InEightDMS.Web/Views/Shared/_Layout.cshtml)

Add chat widget to DMS layout:

```html
<!-- At the end of body, before closing </body> tag -->

@if (User.Identity.IsAuthenticated)
{
    <!-- Chat Widget -->
    <div id="chat-widget-root"></div>
    <script type="module">
        import { ChatWidget } from '/Scripts/chat-widget.js';
        import { createRoot } from 'react-dom/client';
        import { createElement } from 'react';
        
        const root = createRoot(document.getElementById('chat-widget-root'));
        root.render(createElement(ChatWidget, {
            apiBaseUrl: '@Url.Content("~")',
            jwtToken: '@ViewBag.ChatJWT'
        }));
    </script>
}
```

#### [NEW] [InEightDMS.Web/Helpers/JwtHelper.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightDMS/InEightDMS.Web/Helpers/JwtHelper.cs)

Generate JWT for chatbot authentication:

```csharp
using Microsoft.IdentityModel.Tokens;
using System;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace InEightDMS.Web.Helpers
{
    public static class JwtHelper
    {
        private const string SecretKey = "your-secret-key-min-32-chars-shared-with-chatbot";
        private const string Issuer = "InEightDMS";
        private const string Audience = "InEightChatbot";
        
        public static string GenerateToken(int userId, string email, string role)
        {
            var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(SecretKey));
            var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);
            
            var claims = new[]
            {
                new Claim(ClaimTypes.NameIdentifier, userId.ToString()),
                new Claim(ClaimTypes.Email, email),
                new Claim(ClaimTypes.Role, role)
            };
            
            var token = new JwtSecurityToken(
                issuer: Issuer,
                audience: Audience,
                claims: claims,
                expires: DateTime.UtcNow.AddHours(8),
                signingCredentials: credentials
            );
            
            return new JwtSecurityTokenHandler().WriteToken(token);
        }
    }
}
```

#### [MODIFY] [InEightDMS.Web/Controllers/BaseController.cs](file:///d:/Code/ineight/projects/InEightDocumentAISuite/InEightDMS/InEightDMS.Web/Controllers/BaseController.cs)

Add JWT to ViewBag in all controllers:

```csharp
using Microsoft.AspNet.Identity;
using System.Web.Mvc;
using InEightDMS.Web.Helpers;

namespace InEightDMS.Web.Controllers
{
    public class BaseController : Controller
    {
        protected override void OnActionExecuting(ActionExecutingContext filterContext)
        {
            if (User.Identity.IsAuthenticated)
            {
                var userId = User.Identity.GetUserId<int>();
                var email = User.Identity.Name;
                var role = "User"; // Get from database
                
                ViewBag.ChatJWT = JwtHelper.GenerateToken(userId, email, role);
            }
            
            base.OnActionExecuting(filterContext);
        }
    }
}
```

---

## Verification Plan

### Automated Tests

1. **Provider Tests**
   ```powershell
   # Test Ollama connection
   curl http://localhost:11434/api/generate -d '{"model":"llama3","prompt":"Test","stream":false}'
   
   # Test PostgreSQL + pgvector
   docker exec -it postgres-ineight psql -U postgres -d ineightchatbot -c "SELECT version();"
   ```

2. **API Tests**
   ```powershell
   # Start API
   cd InEightAIChatbot.Service
   dotnet run
   
   # Test metadata sync
   curl -X POST http://localhost:5000/api/admin/sync-metadata
   
   # Test chat (with JWT)
   curl -X POST http://localhost:5000/api/chat/message `
     -H "Authorization: Bearer <jwt-token>" `
     -H "Content-Type: application/json" `
     -d '{"query":"Show me IFC drawings"}'
   ```

3. **Integration Tests**
   - Verify DMS can generate JWT
   - Verify chat widget loads in DMS
   - Verify user security filtering
   - Test chat with different user roles

### Manual Verification

1. **End-to-End Flow**
   - Login to DMS
   - Click chat button
   - Ask: "Show me documents uploaded today"
   - Verify results respect user's project access
   - Click document link, verify it opens correct document

2. **Performance Benchmarks**
   - Embedding generation: ~10ms per document
   - Vector search: 50-100ms
   - LLM completion: 2-5 seconds (Ollama on CPU)
   - Total response time: 2-6 seconds

3. **Security Tests**
   - User A cannot see User B's project documents
   - Project Manager sees only their projects
   - Admin sees all documents

---

## Phase 2 Upgrade Path (Azure)

When ready to upgrade to Azure services:

1. **Implement Azure Providers**
   - Remove `NotImplementedException` from Azure provider classes
   - Add NuGet packages: `Azure.AI.OpenAI`, `Azure.Search.Documents`
   - Implement using Azure SDK

2. **Update Configuration**
   ```json
   {
     "AI": {
       "Provider": "AzureOpenAI",
       "VectorStore": "AzureAISearch"
     }
   }
   ```

3. **No Code Changes Required** - Provider abstraction handles the switch

---

## Next Steps

1. Review this implementation plan
2. Approve the hybrid approach (free-tier MVP â†’ Azure upgrade path)
3. Begin Phase 2: Solution Setup & Foundation
